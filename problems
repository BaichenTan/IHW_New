Some questions that I have encountered:

1. cannot load the C++ codes by Rcpp package

A) I have run IHW:::optimal_ts to testify that the results are the same as the gren_objects dataset

B) For lambda = Inf case:
I have use the tg == tg-1 as the new constraint and this aligns with the output given by the ADMM algorithm

When I set lambda = 1e10, the results by the two methods are the same, but when I choose an even larger lambda, the answer deviate, I think this relates to the way the solver deals with an extremely large penalty term?

C) For test_ihw, failures that I have observed:

1. #Error in adjustment_type(object) : could not find function "adjustment_type"

Status: Solved by loading the ihw_class.R

2. #expect: True actual: False
#seems that >= is the correct formula
#what is weights function here
expect_true(all(apply(weights(ihw_res1, levels_only=T),2, IHW:::total_variation) <= ihw_res1@regularization_term + 10^(-12)))

Goal: maximize \sum Fg(tg) - \lam \sum |tg - tg-1|

Old code: 
Maximize: \sum Fg(tg)
FDR <= \alpha
\sum |wg - wg-1| <= \lam, this is equivalent to \sum |tg - tg-1| <= \lam \Sum tg

Check if gurobi results are equal to ADMM


3. # try with only 1 fold
#error: m_groups_other_folds_uncollapsed not found
expect_message(ihw_res1_single_fold <- ihw(sim$pvalue, sim$filterstat, .1, nbins=10, nfolds=1))

I think the issue may because that  m_groups_other_folds_uncollapsed is not specified as the inputs in the function ihw_internal

4. Read through the ADMM stopping strategies to see if there are other stopping rules
which heursitics to choose

5. optimal_CVXR and check its computational time with the new ADMM method (can be combined with step 6?)

extract lambda_max first and then apply that to CVXR

before optimal_ts

if ADMM:
  -optimal_ts

else:
  -compute lambda_max
  -then run CVXR
  
6. Move to step 3: check actual dataset 

 -computational speed: old with ADMM, CVXR with ADMM
 












Feb 12

Do the third dataset example
Run through the old simulations (the new methods)

Simulation file (start with that)
- create a new test file addition to the old one
- a few simulations 
- compare the results output by the CVXR and the new method
- CVXR method may be quite slow (can drop it)
- compare the old with new

Run the hqtl_example analysis
Run the vignettes method

- run time of the three methods
- the new method doesn't degrade things
- correctness of the algorithm

Fix the math prob 

Stopping rules

Fixing the files ☑️



Feb 26

Try different lambdas

Check the stopping criterion (evaluate the objective function, if the weights don't change too much)

If the total variation doesn't change much (stabilize)

 (slow down)

Bin sizes

Making 

Replace 2 by 1.5

Replace 2 by 1.1 works

1.2^7 then replace to 


Mar 4
1. Change the lambdas = c(1.0 / 1.2^(1:7), 1/ 2^(2:13))
Solve the issues
Now the three methods return exactly the same number of rejections (vignettes)

2. Method 2 (Hard code the first few lambdas)?

3. Method 3: other stopping rules?


Go to the old package and rename the functions

1. Delete the export file

2. Replace ihwResult by ihw_oldResutl
Rename all the old functions

3. Delete the plot code from the old ihw 
4. Plot codes work on the new things
Modify on the new one

4. Go to old package / remove exports and rename things

5. Go to the new package and fix the plot function 
Number of bins: additive 4, 8, 12, ..., to 64

6. Bin size vs. time
Rejections vs. time



Mar 12.

Come up with an cdmm stopping criterion

Compared how the code implements it

Add some more stopping criterion
(Make this a bit relaxed (not 1e-10 maybe))


From 1st to the 3rd more power 

Get rid of the blue vertical line at 0

Real Dataset (look at real dataset to see how they look like)

Stretch out the x-axis (three lines)

Make the plots less tall

Finding lambdamax 
(Null single threshold)
Single FDR works for everything


Making the lambdas approximately the same
(Right now the new method has more lambdas)

Specify a pi0 and specify the alternative as sqrt(t)

The local FDR should be like pi0/sqrt(t)

Say the distribution function 

Density is sqrt(x)

(Pi0 + pi1)/ sqrt(t)






1. Line 585: why repeat this procedure
2. 609 Use of this


if 1e-5, then difference
If 1e-



Mar 19

-compile the test file
-main goal is to check the power doesn't lose much



Re-adjust the bins
/1000




